<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Solver.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Solver.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Constraint = require("../constraints/Constraint");
const Wall = require("../walls/Wall");
const Particle = require("./Particle");
const SpatialHashGrid = require("./SpatialHashGrid");

/**
 * `Solver` is the discrete solver algorithm that calculates the movement of the physics world. It uses a modified 
 * predictive-corrective semi-implicit Euler implementation. Because this is a local iterative solver, there may be 
 * divergence issues at higher timeSteps and convergence can be tuned with the iterationPerFrame.
 */
class Solver {
    /**
     * Instantiates new `Solver`
     * @param {Number} timeStep the change in time per frame (smaller is more accurate)
     * @param {Number} iterationPerFrame the amount of time the solver is called per frame (**not** substepping, timeStep remains constant)
     * @param {Number} constraintIteration the amount of times the constraints are solved per frame
     * @param {SpatialHashGrid} particles SpatialHashGrid of particles
     * @param {Constraint[]} constraints list of constraints
     * @param {Wall[]} walls list of walls
     */
    constructor(timeStep, iterationPerFrame, constraintIteration, particles, constraints, walls) {
        this.timeStep = timeStep;
        this.iterationPerFrame = iterationPerFrame;
        this.particles = particles;
        this.constraints = constraints;
        this.constraintIteration = constraintIteration;
        this.run = true;
        this.particles = particles;
        this.particleList = this.particles.values();
        this.walls = walls;
    }

    /**
     * Solves one iteration of the current physics world
     */
    solve() {
        // calculate future pos and store current pos as previous pos
        // apply behaviors, any forces, and corrections
        // calculate constraint correction based on current position
        // apply correction, set forces to 0, apply velocity to get final pos.
        // there might be duplicate processes... i think i need to fix that
        this.preMove();
        this.handleWallCollisions();
        this.update();
        this.handleBehaviors();
        this.handleConstraints();
        this.updateVelocity();
        this.positionCorrection();
    }

    /**
     * Optional function that can be defined to exhibit certain behavior in the solve loop.
     */
    update(){
        return;
    }

    /**
     * Move particle positions forward to the "future-position"
     */
    preMove() {
        for (let circ of this.particleList) {
            circ.prevPos = circ.pos;
            circ.pos = circ.pos.add(circ.vel.mult(this.timeStep));
        }
    }

    /**
     * Solve physics interactions from Behaviors
     */
    handleBehaviors() {
        for (let circ of this.particleList) {

            for (let sb of circ.selfBehavior) {
                sb.applyBehavior(circ, this.timeStep);
            }

            for (let nb of circ.nearBehavior) {
                nb.applyBehavior(circ, this.timeStep, this.particles.findNear(circ, nb.range()));
            }       
        }
    }

    /**
     * Solve physics interactions from Constraints
     */
    handleConstraints() {
        let dt = this.timeStep / this.constraintIteration;
        for (let i = 0; i &lt; this.constraintIteration; i++) {
            for (let c of this.constraints) {
                c.update(dt);
                if (c.breakForce !== (null || Infinity) &amp;&amp; c.force.mag() > c.breakForce) {
                    const index = this.constraints.indexOf(c);
                    if (index > -1) {
                        this.constraints.splice(index, 1);
                    }
                }
            }
        }
    }

    /**
     * Solve collision interactions with Walls
     */
    handleWallCollisions() {
        for (let wall of this.walls) {
            wall.resolveCollisions(this.particles.findNear(wall), this.timeStep);
        }
    }

    /**
     * Update final particle velocities
     */
    updateVelocity() {
        for (let circ of this.particleList) {
            circ.vel = circ.pos.sub(circ.prevPos).mult(1 / this.timeStep);
            this.particles.updateItem(circ);
        }
    }

    /**
     * Correct particle positions 
     */
    positionCorrection() {

        for (let circ of this.particleList) {

            for (let sb of circ.selfBehavior) {
                sb.applyCorrection(circ);
            }

            for (let nb of circ.nearBehavior) {
                nb.applyCorrection(circ, this.particles.findNear(circ, nb.range()));
            }       
        }
   

        for (let wall of this.walls) {
            wall.applyCorrection(this.particles.findNear(wall));
        }
    }

    /**
     * Computes next frame or "world-state"
     */
    nextFrame() {
        for (let i = 0; i &lt; this.iterationPerFrame; i++) {
            this.solve();
        }
    }

    /**
     * Update the particle positions in the SpatialHashGrid
     */
    updateSolverParticles() {
        this.particleList = this.particles.values();
    }
}

module.exports = Solver;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Particle.html">Particle</a></li><li><a href="Solver.html">Solver</a></li><li><a href="SpatialHashGrid.html">SpatialHashGrid</a></li><li><a href="World.html">World</a></li><li><a href="instantiates%2520new%2520SpatialHashGrid.html">instantiates new SpatialHashGrid</a></li><li><a href="interface%2520cannot%2520be%2520instantiated.html">interface cannot be instantiated</a></li></ul><h3>Interfaces</h3><ul><li><a href="HashGridItem.html">HashGridItem</a></li></ul><h3>Global</h3><ul><li><a href="global.html#core">core</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Sat Jun 10 2023 00:27:43 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
