<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\walls\WallBoundary.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src\walls\WallBoundary.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
const Vector2D = require(&quot;../utils/Vector2D&quot;);
const Wall = require(&quot;./Wall&quot;);

/**
 * &#x60;WallBoundary&#x60; is a simple &#x60;Wall&#x60; that is comprised of a straight-line between two spatial coordinates. Wall positions
 * are generally meant to be immutable since the normal vector is calculated upon instantiation. However, wall position
 * can be modified with some care.
 */
class WallBoundary extends Wall {

    /**
     * Instantiates new &#x60;WallBoundary&#x60;
     * @param {*} x1 x-position of first vertex
     * @param {*} y1 y-position of first vertex
     * @param {*} x2 x-position of second vertex
     * @param {*} y2 y-position of second vertex
     * @param {*} width rendered line width of wall (does not effect physics)
     */
    constructor(x1, y1, x2, y2, width=1) {
        super();
        this.p1 = new Vector2D(x1, y1);
        this.p2 = new Vector2D(x2, y2);
        this.direction = this.p1.sub(this.p2);
        this.width = width;
        this.normal = (new Vector2D((y2-y1), -(x2-x1))).normalize();
    }


    /**
     * @override
     * @param {Particle[]} particles 
     * @param {Number} timeStep 
     */
    resolveCollisions(particles, timeStep) {
        for (let particle of particles) {
            let pos = particle.pos;
            let bounciness = particle.bounciness;

            let diff = pos.sub(this.p1);
            let segVect = this.p2.sub(this.p1);
          
            let dot = diff.dot(segVect);
            let len_sq = segVect.magSqr();
    
            let lambda = -1;
            if (len_sq != 0) { 
                lambda = dot / len_sq;
            }
    
            let projected;
          
            if (lambda &lt; 0) {
              projected = this.p1;
            } else if (lambda &gt; 1) {
              projected = this.p2;
            } else {
              projected = this.p1.add(segVect.mult(lambda));
            }
        
            let projectedDiff = pos.sub(projected);
            let distance = projectedDiff.mag();

            if (distance &lt;= particle.radius &amp;&amp; lambda &lt; 0) {
                let velocity = particle.vel;
                let vDot = - (velocity.dot(diff)) / (diff.magSqr());
                velocity.subTo(diff.mult(vDot * 2));
                velocity.multTo(bounciness);
                //particle.vel = (velocity.sub(diff.mult(vDot * 2))).mult(bounciness);
                particle.pos.addTo(diff.mult(vDot * 2 * bounciness * timeStep));
            } else if (distance &lt;= particle.radius &amp;&amp; lambda &gt; 1) {
                let diff = pos.sub(this.p2);
                let velocity = particle.vel;
                let vDot = - (velocity.dot(diff)) / (diff.magSqr());
                velocity.subTo(diff.mult(vDot * 2));
                velocity.multTo(bounciness);
                //particle.vel = (velocity.sub(diff.mult(vDot * 2))).mult(bounciness);
                particle.pos.addTo(diff.mult(vDot * 2 * bounciness * timeStep));
            } else if (distance &lt;= particle.radius) {
                let mag = particle.vel.reflect(this.normal);
                mag.subTo(particle.vel);
                mag.multTo(timeStep);
                particle.vel.reflectTo(this.normal);
                particle.vel.multTo(bounciness);
                //let mag = particle.vel.reflect(this.normal).dot(this.normal);
                //particle.pos = particle.pos.add(this.normal.mult(2 * timeStep * mag * bounciness));
                //let mag = particle.vel.reflect(this.normal).sub(particle.vel).mult(timeStep * bounciness);
                particle.pos.addTo(mag);
            }
        }
    }

    /**
     * @override
     * @param {Particle[]} particles 
     */
    applyCorrection(particles) {
        for (let particle of particles) {
            let pos = particle.pos;

            let diff = pos.sub(this.p1);
            let segVect = this.p2.sub(this.p1);
          
            let dot = diff.dot(segVect);
            let len_sq = segVect.magSqr();
    
            let lambda = -1;
            if (len_sq != 0) { 
                lambda = dot / len_sq;
            }
    
            let projected;
          
            if (lambda &lt; 0) {
              projected = this.p1;
            } else if (lambda &gt; 1) {
              projected = this.p2;
            } else {
              projected = this.p1.add(segVect.mult(lambda));
            }
        
            let projectedDiff = pos.sub(projected);
            let distance = projectedDiff.mag();
            let overlap = distance - particle.radius;

            if ((distance &lt; particle.radius &amp;&amp; lambda &lt; 0) || 
                (distance &lt; particle.radius &amp;&amp; lambda &gt; 1) || 
                (distance &lt; particle.radius)) {
                projectedDiff.normalizeTo();
                projectedDiff.multTo(overlap);
                particle.pos.subTo(projectedDiff);
            }
        }
    }

    /**
     * Checks if a Particle is colliding with the Wall
     * @param {Particle} particle 
     * @returns {Boolean} true if particle is colliding with wall
     */
    isCollide(particle) {
        let pos = particle.pos;
        let diff = pos.sub(this.p1);
        let segVect = this.p2.sub(this.p1);
      
        let dot = diff.dot(segVect);
        let len_sq = segVect.magSqr();

        let lambda = -1;
        if (len_sq != 0) { 
            lambda = dot / len_sq;
        }

        let projected;
      
        if (lambda &lt; 0) {
          projected = this.p1;
        } else if (lambda &gt; 1) {
          projected = this.p2;
        } else {
          projected = this.p1.add(segVect.mult(lambda));
        }

        let projectedDiff = pos.sub(projected);
        let distance = projectedDiff.mag();

        return distance &lt; particle.radius;
    }

    /**
     * @override
     * @returns {[Number, Number]} 
     */
    getHashPos() {
        return [(this.p2.x + this.p1.x) / 2, (this.p2.y + this.p1.y) / 2];
    }

    /**
     * @override
     * @returns {[Number, Number]} 
     */
    getHashDimensions() {
        return [Math.abs(this.p2.x - this.p1.x), Math.abs(this.p2.y - this.p1.y)];
    }

    /**
     * @override
     * @returns {[Vector2D, Vector2D]} 
     */
    vertices() {
        return [this.p1, this.p2];
    }
}

module.exports = WallBoundary;
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
